"""Wrapper around version 2 of the Energy Aspects API"""import requestsimport pandas as pdfrom datetime import dateimport osimport rebase_url = "https://api.energyaspects.com/data/datasets/timeseries/"timeseries_url = "https://api.energyaspects.com/data/timeseries/"api_key = os.getenv('EA_API_KEY')headers = {"Accept": "application/json"}def get_timeseries_def():    querystring = {        "api_key": api_key,    }    response = requests.request("GET", base_url, headers=headers, params=querystring)    alls = pd.read_json(response.text)    alls = pd.merge(alls, alls['metadata'].apply(lambda x: pd.Series(x), 1), left_index=True, right_index=True)    alls = alls.set_index('dataset_id')    alls = alls.drop('metadata', axis=1)    return allsdef extract_region(m):    region = m['country_iso'] # by default use country    if not m['country_iso']:        if m['region']: # if country but do have a region use it            region = m['region']        else:            region = m['description'] # some have neither - use desc    if m['country_iso'] == 'US' and m['sub_region']: # for padds        region = m['sub_region']    return regiondef generate_title(dataset_id:int, metadata:dict, format_title:str):    """    Given metadata generate a title for use in data frames.    eg region.aspect would give 'US.demand'    :param dataset_id:    :param metadata:    :param format_title:    :return:    """    m = metadata[str(dataset_id)]    title = format_title    for token in format_title.split('.'):        if token == 'extract_region':            title = re.sub(token, extract_region(m), title)        else:            title = re.sub(token, m[token],title)    return titledef extract_data(s, id_):    r = pd.Series(s)    r.index = pd.to_datetime(r.index)    r.name = id_    return rdef read_timeseries(format_title:str = None, **kwargs) -> pd.DataFrame():    querystring = { "api_key": api_key }    for kwarg in kwargs:        if kwarg == 'dataset_id':            querystring["dataset_id"] = [str(x) for x in kwargs[kwarg]]        if kwarg in ['category', 'category_detail', 'frequency', 'aspect', 'aspect_detail']:            querystring[kwarg] = kwargs[kwarg]        if kwarg in ['date_from', "date_to"]:            querystring[kwarg] = kwargs[kwarg].strftime("%Y-%m-%d")    response = requests.request("GET", timeseries_url, headers=headers, params=querystring)    if response.status_code == 200:        df = pd.read_json(response.text)        data = df.apply(lambda x: extract_data(x.data, x.dataset_id), 1)        data.index = data.index.map(lambda x: df.loc[x].dataset_id)        data = data.T        meta = df['metadata'].to_dict()        meta = {meta[x]['dataset_id'] :meta[x] for x in meta}        if format_title:            cmap = {x: generate_title(x, meta, format_title=format_title) for x in data.columns}            data = data.rename(columns=cmap)            for t in cmap: # add this title back to metadata to link metadata to columns                meta[str(t)]['title'] = cmap[t]        # keep the metadata in the attrs of df        data.attrs['metadata'] = meta        return data    else:        return (response.status_code, response.text)def detailed_metadata(id_: int) -> pd.DataFrame:    querystring = { "api_key": api_key, }    response = requests.request("GET", '%s%s' % (base_url, id_), headers=headers, params=querystring)    if response.status_code == 200:        df = pd.read_json(response.text)        df = df['metadata']        df.name = id_        data = pd.DataFrame(df)        return data.Tdef read_commod_balance(commod:str, date_from:date = None) -> pd.DataFrame:    format_title = 'extract_region.aspect'    if commod == 'crude':        category = 'crude_oil'    else:        category = 'oil_products'    df = read_timeseries(category = category, category_detail=commod, frequency='monthly', date_from=date_from, format_title=format_title)    return df